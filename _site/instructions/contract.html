<!DOCTYPE html>
<html lang="en" ng-app="jpm">

	<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="/css/style.css" rel="stylesheet" />
<title>bnd</title>

	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	

</head>


<body>

	
<ul class="container12 menu-bar">
	<li span=5><a class=menu-link href="/"><img
			class=menu-logo src='/img/bnd-80x40-white.png'></a>
			<a href="">A</a><a href="">B</a>
	<li class=menu-link span=4>
	<li class=menu-link span=3>
</ul>


					

	<ul class=container12>
		<li span=3>
			<div>
			<ul class="side-nav">
	
	<li><a href="/chapters/110-introduction.html">Introduction</a> 
	<li><a href="/chapters/120-install.html">Where to find it</a> 
	<li><a href="/chapters/130-concepts.html">Concepts</a> 
	<li><a href="/chapters/140-best-practices.html">Best practices</a> 
	<li><a href="/chapters/150-build.html">Build</a> 
	<li><a href="/chapters/160-jars.html">Generating JARs</a> 
	<li><a href="/chapters/170-versioning.html">Versioning</a> 
	<li><a href="/chapters/200-components.html">Service Components</a> 
	<li><a href="/chapters/210-metatype.html">Metatype</a> 
	<li><a href="/chapters/220-contracts.html">Contracts</a> 
	<li><a href="/chapters/300-launching.html">Launching</a> 
	<li><a href="/chapters/310-testing.html">Testing</a> 
	<li><a href="/chapters/320-packaging.html">Packaging Applications</a> 
	<li><a href="/chapters/400-commandline.html">From the command line</a> 
	<li><a href="/chapters/600-developer.html">For Developers</a> 
	<li><a href="/chapters/700-tools.html">Tools bound to bnd</a> 
	<li><a href="/chapters/790-format.html">File Format</a> 
	<li><a href="/chapters/800-headers.html">Header Reference</a> 
	<li><a href="/chapters/820-instructions.html">Instruction Reference</a> 
	<li><a href="/chapters/850-macros.html">Macro Reference</a> 
	<li><a href="/chapters/880-settings.html">Settings</a> 
	<li><a href="/chapters/900-errors.html">Errors</a> 
	<li><a href="/chapters/910-faq.html">Frequently Asked Questions</a> 
</ul>

			</div>
			
		<li span=9>
			<div class=notes-margin>
				<h1> -contract</h1>
				<pre><code>	package aQute.bnd.osgi;
	
	import java.util.*;
	import java.util.Map.Entry;
	
	import org.osgi.namespace.contract.*;
	
	import aQute.bnd.header.*;
	import aQute.bnd.osgi.Descriptors.PackageRef;
	import aQute.bnd.version.*;
	import aQute.lib.collections.*;
	import aQute.service.reporter.Report.Location;
	
	/**
	 * OSGi Contracts are first defined in OSGi Enterprise Release 5.0.0. A Contract
	 * is a namespace to control the versioning of a set of packages.
	 * 
	 * @author aqute
	 */
	class Contracts {
	
		private Analyzer									analyzer;
		private final MultiMap&lt;PackageRef,Contract&gt;			contracted				= new MultiMap&lt;PackageRef,Contract&gt;(
																							PackageRef.class,
																							Contract.class, true);
		private MultiMap&lt;Collection&lt;Contract&gt;,PackageRef&gt;	overlappingContracts	= new MultiMap&lt;Collection&lt;Contract&gt;,PackageRef&gt;();
		private Instructions								instructions;
		private final Set&lt;Contract&gt;							contracts				= new HashSet&lt;Contract&gt;();
	
		public class Contract {
			public String				name;
			public Attrs				decorators;
			public Collection&lt;String&gt;	uses;
			public Version				version;
			public String				from;
	
			@Override
			public String toString() {
				return "Contract [name=" + name + ";version=" + version + ";from=" + from + "]";
			}
	
		}
	
		public Contracts(Analyzer analyzer) {
			this.analyzer = analyzer;
		}
	
		Instructions getFilter() {
			if (instructions == null) {
				String contract = analyzer.getProperty(Constants.CONTRACT);
				this.instructions = new Instructions(contract);
			}
			return instructions;
		}
	
		public void clear() {
			contracted.clear();
			overlappingContracts.clear();
			contracts.clear();
		}
	
		/**
		 * Collect contracts will take a domain and find any declared contracts.
		 * This happens early so that we have a list of contracts we can later
		 * compare the imports against.
		 */
		void collectContracts(String from, Parameters pcs) {
	
			contract: for (Entry&lt;String,Attrs&gt; p : pcs.entrySet()) {
				String namespace = p.getKey();
	
				if (namespace.equals(ContractNamespace.CONTRACT_NAMESPACE)) {
					Attrs capabilityAttrs = p.getValue();
	
					String name = capabilityAttrs.get(ContractNamespace.CONTRACT_NAMESPACE);
					if (name == null) {
						analyzer.warning("No name (attr %s) defined in bundle %s from contract namespace: %s",
								ContractNamespace.CONTRACT_NAMESPACE, from, capabilityAttrs);
						continue contract;
					}
	
					for (Entry&lt;Instruction,Attrs&gt; i : getFilter().entrySet()) {
						Instruction instruction = i.getKey();
						if (instruction.matches(name)) {
							if (instruction.isNegated()) {
								analyzer.trace("%s rejected due to %s", namespace, instructions);
								continue contract;
							}
	
							analyzer.trace("accepted %s", p);
	
							Contract c = new Contract();
							c.name = name;
	
							String list = capabilityAttrs.get(ContractNamespace.CAPABILITY_USES_DIRECTIVE + ":");
							if (list == null || list.length() == 0) {
								analyzer.warning("Contract %s has no uses: directive in %s.", name, from);
								continue contract; // next contract
							}
	
							c.uses = Processor.split(list);
	
							c.version = (Version) capabilityAttrs.getTyped(ContractNamespace.CAPABILITY_VERSION_ATTRIBUTE);
							c.from = from;
	
							if (c.version == null) {
								c.version = Version.LOWEST;
								analyzer.warning("%s does not declare a version, assumed 0.0.0.", c);
							}
							c.decorators = new Attrs(i.getValue());
	
							//
							// Build up the package -&gt; contract index
							//
							for (String pname : c.uses) {
								contracted.add(analyzer.getPackageRef(pname), c);
							}
						}
					}
				}
			}
		}
	
		/**
		 * Find out if a package is contracted. If there are multiple contracts for
		 * a package we remember this so we can generate a single error.
		 * 
		 * @param packageRef
		 * @return
		 */
		boolean isContracted(PackageRef packageRef) {
			List&lt;Contract&gt; list = contracted.get(packageRef);
			if (list == null || list.isEmpty())
				return false;
	
			if (list.size() &gt; 1) {
	
				//
				// There are multiple contracts trying to address
				// this package. We collect those so we can report them
				// as one error instead of one for each package
				//
	
				overlappingContracts.add(list, packageRef);
			}
			contracts.addAll(list);
			return true;
		}
	
		/**
		 * Called before we print the manifest. Should add any contracts that were
		 * actually used to the requirements.
		 * 
		 * @param requirements
		 */
		void addToRequirements(Parameters requirements) {
			for (Contract c : contracts) {
				Attrs attrs = new Attrs(c.decorators);
				attrs.put(ContractNamespace.CONTRACT_NAMESPACE, c.name);
				String range = analyzer.applyVersionPolicy(c.version.toString(), c.decorators.getVersion(), false);
				String name = ContractNamespace.CONTRACT_NAMESPACE;
				while (requirements.containsKey(name))
					name += "~";
	
				VersionRange r = new VersionRange(range);
	
				Formatter f = new Formatter();
				try {
					f.format("(&amp;(%s=%s)%s)", ContractNamespace.CONTRACT_NAMESPACE, c.name, r.toFilter());
	
					// TODO : shall we also assert the attributes?
	
					attrs.put("filter:", f.toString());
	
					requirements.put(name, attrs);
				}
				finally {
					f.close();
				}
			}
	
			for (Entry&lt;Collection&lt;Contract&gt;,List&lt;PackageRef&gt;&gt; oc : overlappingContracts.entrySet()) {
				Location location = analyzer
						.error("Contracts %s declare the same packages in their uses: directive: %s. "
								+ "Contracts are found in declaring bundles (see their 'from' field), it is possible to control the finding"
								+ "with the -contract instruction", oc.getKey(), oc.getValue()).location();
				location.header = Constants.CONTRACT;
			}
		}
	
	}
</code></pre>

			</div>
	</ul>

	
<nav class=next-prev>
	<a href=''></a> <a href=''></a>
</nav>
<footer class="container12" style="border-top: 1px solid black;padding:10px 0">
	<ul span=12 row>
		<li span=3>
			<ul>
				<li><a href="/contact.html">Contact</a>
			</ul>
		<li span=3>
			<ul>
				<li><a href="">Developers</a>
			</ul>
		<li span=3>
			<ul>
				<li><a href="">More</a>
			</ul>
	</ul>
</footer>


</body>
</html>
